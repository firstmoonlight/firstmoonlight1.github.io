自从写了上一篇文章之后，了解了C++返回对象时所做的动作之后，对于形参的操作，我这边也做一些简要的介绍，主要是参考了下面这个连接中的内容。
[老生常谈C++中实参形参的传递问题](https://www.jb51.net/article/108390.htm)

# 非引用非指针形参
非引用形参采用的是值传递的形式，即函数调用的时候，传递的是实参的副本。因此函数中对形参的修改是不会影响实参的值的。

## const修饰
* 如果函数使用的是非引用非const形参，则可以给它传递const实参，也可以传递非const实参。
* 如果函数使用非引用的const形参，可以传递给它const实参和非const实参。

# 引用或指针形参
* 引用形参和指针形参可以改变实参的值。从汇编代码角度看，引用形参和指针形参最后的汇编代码都是一样，全部用的指针传递。
* 引用形参和指针形参相对于值传递的优势在于：
    1. 避免了函数调用时实参对象的拷贝。
    2. 可以修改实参，实现函数的额外信息的返回

## const修饰
* const修饰引用时，在函数内部不能对实参进行修改。**可以接受右值**。
* const修饰指针时，在函指内部不能修改指针指向的内容。

## 指向指针的引用
这个应用场景我暂时也没有遇到过。做个记录吧。
```
void swap(int *&lhs, int*&rhs) {
    int *tmp = lhs;
    lhs = rhs;
    rhs = tmp;
}
```

# 右值引用形参
右值形参只能接受右值。

# vector和其它容器类型的形参
由于复制vector会使得效率降低，多以如果形参是vector的话，我们常常将该形参声明为引用，避免复制。另一种方法在C++中更为常用，就是通过传递指向容器中需要处理的元素的迭代器来传递容器。

# 数组形参
## 数组指针形参
```
void fun(int * arr);
void fun(int[] arr);
void fun(int[10] arr);
```
上面的三个函数在编译器进行编译之后，都会转化为`void fun(int *)`的形式，即它们是同一种表述，都是传递数组的指针（从下面的编译错误中可以看出）。因此不会检查数组的长度，实参数组的长度与形参不匹配不会报错。


<img src="https://github.com/firstmoonlight/MarkdownImages/blob/main/2024_7_8/Image19.png" width="70%">

## 数组引用形参
```
void fun(int (&arr)[10]); 
```
对于引用型形参来说，编译器还会检查是数组的大小与形参的大小是否匹配，所以如果实参数组的长度与形参不匹配，编译时就会报错。

## 简单例子
```
void fun1(int arr[0]){};
void fun2(int (&arr)[10]){};

int main() {
    int a[20];
    int b[20];
    fun1(a);    //编译不会报错
    fun2(a);    //编译报错
}

```
# 可变形参
C++中的省略符形参是为了编译使用了varargs的C语言程序。
```
void foo(param_list, ...);
void foo(...);
```
